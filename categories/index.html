<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Categories">

    <link rel="alternate" type="application/rss+xml" href="/categories/index.xml" title="" />
    
        <title>Categories | </title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.375e5ed55aac1492efe66cf6fd686d0af88cb56b12d6bafab6571d3b39c73883.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
          </ul>
        </nav>
        


<h1>Categories</h1>

<ul class="terms">
  
</ul>

<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 200),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "\/post\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "\/post\/"
    },
    
    "\/": {
        "title": "",
        "tags": [],
        "content": " ", 
        "url": "\/"
    },
    
    "\/post\/oxygen\/": {
        "title": "Oxygen",
        "tags": [],
        "content": "Info about the craziest personal project I\u0026rsquo;ve ever worked on.\nPreface In January 2024, I submitted a project for the Develop at Ubisoft Toronto competition. It was a simple isometric, local multiplayer game that I had crunched over a couple of days to complete. I was not overly proud of it. It was a lazy attempt just to get something done.\nThough I was entirely confident of my skills as a programmer and felt as though I nailed the interview, this project was a mess. Coming in second place was not a massive surprise; I certainly hoped for a different outcome, but I was aware that I needed to push myself further.\nOn the train ride back to Ottawa, I sat down with a notepad, and like a mad detective working the case that will define their career, frantically wrote every thought down with nearly indecipherable connections being drawn page-to-page. This would become my next project for next year\u0026rsquo;s competition, oxygen.\nStart The API that Ubisoft has been giving for the challenge has been largely unchanged for the past 8 years. It is extremely limited and even comes with its share of bugs that remain unfixed as I am writing this. Here\u0026rsquo;s what you get:\nA solid colour line rendering method A solid colour text rendering method, with only a select few fonts and sizes to choose from Audio playing methods (with surprisingly, no way to change the volume) Keyboard / Mouse input methods Controller input class (with no way to check if a controller is connected) And finally, a sprite class The guidelines of the competition explicitly forbid modifying any of the API code or using libraries like OpenGL to render.\nIn my 2024 project, I had done a ridiculous trick to check if a controller was plugged in:\nThe member of CController, m_bConnected, is marked as protected:\nclass CController { public: // ... protected: XINPUT_STATE m_state; WORD m_lastButtons = 0; WORD m_debouncedButtons = 0; bool m_bConnected = false; }; There are several public methods to check the input state of the controller, but not one to check if it is connected. But by making a child class of CController, it is possible to copy the value from the parent class instance and create a new public method to return it.\nauto IsControllerConnected(const CController\u0026amp; controller) -\u0026gt; bool { struct ControllerChild : public CController { auto IsConnected() const -\u0026gt; bool { return m_bConnected; } }; // To guarantee this causes no side effects: static_assert(std::is_trivially_constructible_v\u0026lt;ControllerChild, const CController\u0026amp;\u0026gt;, \u0026#34;please make a getter for m_bConnected\u0026#34;); static_assert(std::is_trivially_destructible_v\u0026lt;ControllerChild\u0026gt;, \u0026#34;please make a getter for m_bConnected\u0026#34;); ControllerChild child{ controller }; return child.IsConnected(); } This is the type of ridiculous thinking you must do when you are tasked with making something from a poorly designed API.\nPrivacy Sitting on the train I thought more about this insane trick. I wondered if it could be used in other places of the API. Thinking I had just stumbled upon an amazing idea I jumped to check the CSimpleSprite class on my phone. But oh no, these members are private!\nclass CSimpleSprite { public: // ... private: // ... GLuint m_texture; float m_xpos = 0.0f; float m_ypos = 0.0f; float m_width = 0.0f; float m_height = 0.0f; int m_texWidth = 0; int m_texHeight = 0; float m_angle = 0.0f; float m_scale = 1.0f; float m_points[8]; float m_uvcoords[8]; unsigned int m_frame; unsigned int m_nColumns; unsigned int m_nRows; float m_red = 1.0f; float m_green = 1.0f; float m_blue = 1.0f; // ... }; Sadly, no amount of deriving would allow me to access these members. But I knew there had to be a way.\nI knew from my days of game-hacking that it is possible to just modify these members with some simple pointer arithmetic, but that is completely undefined behaviour. Sure, it\u0026rsquo;d work, but guaranteeing that it would work on every different release of MSVC? Impossible.\nAnother option? #define private public your problems away. However, this is also terrible, as far as I can tell it breaks the standard in both defining away keywords (a big no-no), as well as violating the one-definition rule (ODR).\nSo, I sat in defeat. Until I remembered this bizarre rule in the standard: explicit template instantiations have access checks disabled.\nWhy? Imagine you have a class, that itself contains a definition of a class. However, this nested class is marked as private:\nstruct Foo { private: struct Bar{}; }; How would you make an explicit instantiation of this type \u0026lsquo;Bar\u0026rsquo;? Do you put it inside the definition of \u0026lsquo;Foo\u0026rsquo;? Well, no, you cannot explicitly instantiate inside of a class, it has to be done outside of any definitions.\ntemplate struct SomeTemplate\u0026lt;Foo::Bar\u0026gt;; This is why access checks are disabled, they have to be otherwise it\u0026rsquo;d be impossible to explicitly instantiate.\nHow is this useful Doing more research into this, I discovered this blog post: https://web.archive.org/web/20120401132446/http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html // use struct A { A(int a):a(a) { } private: int a; }; // tag used to access A::a struct A_f { typedef int A::*type; friend type get(A_f); }; template struct Rob\u0026lt;A_f, \u0026amp;A;::a\u0026gt;; int main() { A a(42); std::cout \u0026lt;\u0026lt; \u0026#34;proof: \u0026#34; \u0026lt;\u0026lt; a.*get(A_f()) \u0026lt;\u0026lt; std::endl; } This is just the shenanigans I was looking for. An absurd way to access private members of a class, completely defined by the C++ standard.\nPlaying with this, with a more modern version of C++, I came up with this:\n// When explicitly instantiated, this assigns a // non-type-template-parameter value to a reference during global // initialization template \u0026lt;auto\u0026amp; Where, auto What\u0026gt; requires std::convertible_to\u0026lt;decltype(Where), decltype(What)\u0026gt; struct NTTPAssigner { static inline decltype(auto) s_assignmentReturnResult{Where = What}; }; int PrivateClass::*g_privateClassBPointer{}; template struct NTTPAssigner\u0026lt;g_privateClassBPointer, \u0026amp;PrivateClass::b\u0026gt;; // Effectively, this is roughly equivalent to: // int PrivateClass::*g_privateClassBPointer = \u0026amp;PrivateClass::b; So there we go! A way to access private members of the API.\nPutting it into action The first two members of the API that immediately caught my attention were m_points and m_uvcoords. Using this ridiculous syntax (seriously why is this the syntax for a pointer to a sized array member):\n// float m_points[8]; static inline float (CSimpleSprite::*g_CSimpleSpriteMemberPointerMPoints)[8]{}; template struct NTTPAssigner\u0026lt;g_CSimpleSpriteMemberPointerMPoints, \u0026amp;CSimpleSprite::m_points\u0026gt;; // float m_uvcoords[8]; static inline float (CSimpleSprite::*g_CSimpleSpriteMemberPointerMUVCoords)[8]{}; template struct NTTPAssigner\u0026lt;g_CSimpleSpriteMemberPointerMUVCoords, \u0026amp;CSimpleSprite::m_uvcoords\u0026gt;; I was able to move the points and texture coordinates of the sprite anywhere I wanted. This allowed me to render a fully skewed polygon.\nRendering There\u0026rsquo;s a problem, we are still stuck in 2D. The Draw method of the sprite class only passed in 2D coordinates, with no Z value, and no perspective correction.\nBut that doesn\u0026rsquo;t mean 3D is impossible. These are the same limitations the Sony PlayStation and Sega Saturn had, yet we all remember those consoles for their 3D graphics.\nHow do you do 3D without a Z-buffer? The simplest technique is the painter\u0026rsquo;s algorithm. You draw the back-most polygons first. But without clipping every polygon with every polygon that overlaps its plane, this is impossible. Clipping polygons is expensive, and my early N^2 attempt proved to be a complete failure.\nSo how did the developers of the 90s do it? They didn\u0026rsquo;t. They took the average Z value of every polygon and sorted them by that. If you go back and play these early 3D games, you will quickly notice polygons being drawn in the wrong order.\nBut one game had a genius solution, Quake. With a pre-computation stage during level design, all polygons are clipped and a binary-space-partition (BSP) tree is created.\nThe BSP tree gives polygon order in whichever way you want. Back-to-front? Front-to-back? It can handle it. This is a perfect solution.\nThe source code for Quake is freely available online, and although the code is a little bit of a nightmare to decipher, I was able to parse the BSP file format in my codebase.\nThe perspective issue There is no perspective texture correction. This is fine when looking from a far distance at small polygons. But as soon as polygons are close to the camera, or god-forbid, perpendicular with it, they skew massively.\nI was able to slightly remedy this with clipping against the view frustum, however, this does increase the count of polygons we need to draw.\nThe solution? Don\u0026rsquo;t render textures where this effect is obvious. I settled on mostly flat colours in the final project, which perspective warping had little impact on.\nDynamic objects Sure, we can render a static scene. That\u0026rsquo;s great! But how do we move things?\nWe could insert them into the BSP tree, clip them, etc. But this would be very slow (and complex).\nHow did Quake do this? It had a Z-buffer.\nUgh.\nWriting a rasterizer I had previously written a software rasterizer. It\u0026rsquo;s rather simple, you calculate the bounding box (min/max) of the triangle on the screen, iterate over every pixel, calculate the barycentric coordinates, test if they are inside the triangle, and there you go!\nI knew this would be slow as hell. But through months of tweaking, I was able to get it to a point where I was comfortable with it.\nThe trick Quake used to speed it up? You already have sorted polygons for the level geometry, which you don\u0026rsquo;t need to perform any depth testing on, all you need to do is write the Z value.\nMulticore Back in the ye ol\u0026rsquo; days, you got one thread, that\u0026rsquo;s it. Now we have parallel execution. Which can massively speed things up.\nQuickly wrapping my rasterizing code into a std::for_each with std::execution::par_unseq, my frame time went from 90ms to 4ms. I was flabbergasted at how easy it was to exponentially speed up my code. I love modern hardware.\nSo we have a Z-buffer, how do we draw Typically you have two buffers, Z, and colour. This design could work. Draw a quad for every pixel using its colour, but that is a lot of quads. On top of this, it means you must sample the texture on the CPU, which is even more crippling to performance.\nInstead of a colour buffer, I settled on a \u0026ldquo;triangle-buffer\u0026rdquo;, and write the index of the triangle into that buffer, alongside the Z depth. After we have finished rastering, we can iterate this triangle-buffer, and create horizontal spans. These spans can be one pixel or could be the whole width of the screen, chopping down on the amount of polygons we send to the GPU.\nMore to be added in the future ", 
        "url": "\/post\/oxygen\/"
    },
    
    "\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "\/categories\/"
    },
    
    "\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "\/tags\/"
    },
    
}
</script>


    <script defer src="/js/lunr.js"></script>
    <script defer src="/js/search.js"></script>


</footer>

</body>
</html>

